resttemplate.connection.timeout=60
resttemplate.read.timeout=60

# kafka
#spring.kafka.bootstrap-servers=localhost:9192,localhost:9292,localhost:9392
# ack策略
# 0：生产者发送消息就不管了，效率高，但是容易丢数据，且没有重试机制
# 1：消息发送到Leader并落盘后就返回，如果Leader挂了并且Follower还没有同步数据就会丢失数据
# -1：消息要所有副本都罗盘才返回，保证数据不丢失（但是有可能重复消费）
spring.kafka.producer.acks=-1
spring.kafka.producer.retries=2
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.producer.properties.request.timeout.ms=5000

# springKafka 配置信息
spring.kafka.bootstrap-servers=127.0.0.1:9192,127.0.0.1:9292,127.0.0.1:9392
spring.kafka.client-id=springKafkaClient
spring.kafka.template.default-topic=demo

# springKafka 消费者配置
spring.kafka.consumer.bootstrap-servers=127.0.0.1:9192,127.0.0.1:9292,127.0.0.1:9392
spring.kafka.consumer.group-id=demogroup
spring.kafka.consumer.properties.topic=demo
spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer
spring.kafka.consumer.value-deserializer=org.apache.kafka.common.serialization.StringDeserializer
spring.kafka.consumer.enable-auto-commit=true
spring.kafka.consumer.auto-offset-reset=earliest

# 自定义 kafka 信息
my.kafka.enabled=true
my.kafka.bootStrapServer=127.0.0.1:9192,127.0.0.1:9292,127.0.0.1:9392
my.kafka.clientId=111
my.kafka.topic=demo


# springRedis 配置
#spring.redis.host=127.0.0.1
#spring.redis.port=6379
spring.redis.cluster.nodes=127.0.0.1:6381,127.0.0.1:6382,127.0.0.1:6383,127.0.0.1:6384
spring.redis.password=123456
spring.redis.cluster.max-redirects=3
spring.redis.timeout=3000
spring.redis.client-type=jedis
spring.redis.jedis.pool.enabled=true
spring.redis.jedis.pool.time-between-eviction-runs=1000
spring.redis.client-name=myBoot
